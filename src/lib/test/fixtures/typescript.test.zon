.{
    .language = "typescript",
    .parser_tests = .{
        .{
            .name = "functions_and_interfaces",
            .source =
            \\interface User {
            \\    id: number;
            \\    name: string;
            \\    email?: string;
            \\}
            \\
            \\function createUser(name: string, email?: string): User {
            \\    return {
            \\        id: Math.random(),
            \\        name,
            \\        email
            \\    };
            \\}
            \\
            \\const getUserById = async (id: number): Promise<User | null> => {
            \\    const response = await fetch(`/api/users/${id}`);
            \\    return response.json();
            \\};
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .full = true },
                    .expected =
                    \\interface User {
                    \\    id: number;
                    \\    name: string;
                    \\    email?: string;
                    \\}
                    \\
                    \\function createUser(name: string, email?: string): User {
                    \\    return {
                    \\        id: Math.random(),
                    \\        name,
                    \\        email
                    \\    };
                    \\}
                    \\
                    \\const getUserById = async (id: number): Promise<User | null> => {
                    \\    const response = await fetch(`/api/users/${id}`);
                    \\    return response.json();
                    \\};
                    ,
                },
                .{
                    .flags = .{ .signatures = true },
                    .expected =
                    \\function createUser(name: string, email?: string): User
                    \\const getUserById = async (id: number): Promise<User | null> =>
                    ,
                },
                .{
                    .flags = .{ .types = true },
                    .expected =
                    \\interface User {
                    \\    id: number;
                    \\    name: string;
                    \\    email?: string;
                    \\}
                    ,
                },
            },
        },
        .{
            .name = "classes_and_generics",
            .source =
            \\class DataStore<T> {
            \\    private items: T[] = [];
            \\    
            \\    constructor(private name: string) {}
            \\    
            \\    add(item: T): void {
            \\        this.items.push(item);
            \\    }
            \\    
            \\    getAll(): T[] {
            \\        return [...this.items];
            \\    }
            \\    
            \\    findById(id: string): T | undefined {
            \\        return this.items.find((item: any) => item.id === id);
            \\    }
            \\}
            \\
            \\type EventHandler<T = any> = (event: T) => void;
            \\
            \\enum Status {
            \\    PENDING = "pending",
            \\    COMPLETED = "completed",
            \\    FAILED = "failed"
            \\}
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .types = true },
                    .expected =
                    \\class DataStore<T> {
                    \\    private items: T[] = [];
                    \\    
                    \\    constructor(private name: string) {}
                    \\    
                    \\    add(item: T): void {
                    \\        this.items.push(item);
                    \\    }
                    \\    
                    \\    getAll(): T[] {
                    \\        return [...this.items];
                    \\    }
                    \\    
                    \\    findById(id: string): T | undefined {
                    \\        return this.items.find((item: any) => item.id === id);
                    \\    }
                    \\}
                    \\type EventHandler<T = any> = (event: T) => void;
                    \\enum Status {
                    \\    PENDING = "pending",
                    \\    COMPLETED = "completed",
                    \\    FAILED = "failed"
                    \\}
                    ,
                },
                .{
                    .flags = .{ .signatures = true },
                    .expected =
                    \\constructor(private name: string)
                    \\add(item: T): void
                    \\getAll(): T[]
                    \\findById(id: string): T | undefined
                    ,
                },
            },
        },
        .{
            .name = "imports_and_exports",
            .source =
            \\import { Component, useEffect, useState } from 'react';
            \\import type { User, ApiResponse } from './types';
            \\import * as utils from '../utils';
            \\import config from '../config.json';
            \\
            \\export interface Props {
            \\    userId: string;
            \\    onUpdate?: (user: User) => void;
            \\}
            \\
            \\export const UserProfile: Component<Props> = ({ userId, onUpdate }) => {
            \\    const [user, setUser] = useState<User | null>(null);
            \\    
            \\    useEffect(() => {
            \\        loadUser();
            \\    }, [userId]);
            \\    
            \\    return <div>{user?.name}</div>;
            \\};
            \\
            \\export default UserProfile;
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .imports = true },
                    .expected =
                    \\import { Component, useEffect, useState } from 'react';
                    \\import type { User, ApiResponse } from './types';
                    \\import * as utils from '../utils';
                    \\import config from '../config.json';
                    ,
                },
                .{
                    .flags = .{ .signatures = true },
                    .expected =
                    \\export const UserProfile: Component<Props> = ({ userId, onUpdate }) =>
                    ,
                },
            },
        },
        .{
            .name = "advanced_types",
            .source =
            \\type StringOrNumber = string | number;
            \\type KeyValuePair<T> = {
            \\    [K in keyof T]: T[K];
            \\};
            \\
            \\interface Repository<T extends { id: string }> {
            \\    find(id: string): Promise<T | null>;
            \\    save(entity: T): Promise<T>;
            \\    delete(id: string): Promise<void>;
            \\}
            \\
            \\type PartialUser = Partial<User>;
            \\type RequiredUser = Required<User>;
            \\type UserKeys = keyof User;
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .types = true },
                    .expected =
                    \\type StringOrNumber = string | number;
                    \\type KeyValuePair<T> = {
                    \\    [K in keyof T]: T[K];
                    \\};
                    \\interface Repository<T extends { id: string }> {
                    \\    find(id: string): Promise<T | null>;
                    \\    save(entity: T): Promise<T>;
                    \\    delete(id: string): Promise<void>;
                    \\}
                    \\type PartialUser = Partial<User>;
                    \\type RequiredUser = Required<User>;
                    \\type UserKeys = keyof User;
                    ,
                },
            },
        },
        .{
            .name = "docs_and_comments",
            .source =
            \\/**
            \\ * User management service
            \\ * @param config Service configuration
            \\ */
            \\export class UserService {
            \\    /**
            \\     * Create a new user
            \\     * @param userData User data to create
            \\     * @returns Promise resolving to created user
            \\     */
            \\    async createUser(userData: CreateUserData): Promise<User> {
            \\        // Validate user data first
            \\        this.validateUserData(userData);
            \\        return this.repository.save(userData);
            \\    }
            \\}
            \\
            \\// Utility function for formatting
            \\function formatName(name: string): string {
            \\    return name.trim().toLowerCase();
            \\}
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .docs = true },
                    .expected =
                    \\/**
                    \\ * User management service
                    \\ * @param config Service configuration
                    \\ */
                    \\/**
                    \\     * Create a new user
                    \\     * @param userData User data to create
                    \\     * @returns Promise resolving to created user
                    \\     */
                    \\// Validate user data first
                    \\// Utility function for formatting
                    ,
                },
                .{
                    .flags = .{ .signatures = true },
                    .expected =
                    \\async createUser(userData: CreateUserData): Promise<User>
                    \\function formatName(name: string): string
                    ,
                },
            },
        },
        .{
            .name = "error_handling",
            .source =
            \\interface CustomError extends Error {
            \\    code: number;
            \\    details?: string;
            \\}
            \\
            \\class ValidationError extends Error {
            \\    constructor(message: string) {
            \\        super(message);
            \\        this.name = 'ValidationError';
            \\    }
            \\}
            \\
            \\function processData(data: any): Result<ProcessedData, CustomError> {
            \\    try {
            \\        validateData(data);
            \\        return processValidData(data);
            \\    } catch (error) {
            \\        if (error instanceof ValidationError) {
            \\            throw new CustomError('Data validation failed');
            \\        }
            \\        throw error;
            \\    } finally {
            \\        cleanupResources();
            \\    }
            \\}
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .errors = true },
                    .expected =
                    \\interface CustomError extends Error {
                    \\    code: number;
                    \\    details?: string;
                    \\}
                    \\try {
                    \\        validateData(data);
                    \\        return processValidData(data);
                    \\    } catch (error) {
                    \\        if (error instanceof ValidationError) {
                    \\            throw new CustomError('Data validation failed');
                    \\        }
                    \\        throw error;
                    \\    } finally {
                    \\        cleanupResources();
                    \\    }
                    ,
                },
                .{
                    .flags = .{ .types = true },
                    .expected =
                    \\interface CustomError extends Error {
                    \\    code: number;
                    \\    details?: string;
                    \\}
                    \\class ValidationError extends Error {
                    \\    constructor(message: string) {
                    \\        super(message);
                    \\        this.name = 'ValidationError';
                    \\    }
                    \\}
                    ,
                },
            },
        },
        .{
            .name = "structure_overview",
            .source =
            \\import { Database } from './database';
            \\import type { Config } from './config';
            \\
            \\export interface UserRepository {
            \\    findById(id: string): Promise<User | null>;
            \\    save(user: User): Promise<User>;
            \\}
            \\
            \\export class DefaultUserRepository implements UserRepository {
            \\    constructor(private db: Database) {}
            \\    
            \\    async findById(id: string): Promise<User | null> {
            \\        const result = await this.db.query('SELECT * FROM users WHERE id = ?', [id]);
            \\        return result ? this.mapToUser(result) : null;
            \\    }
            \\    
            \\    async save(user: User): Promise<User> {
            \\        return this.db.insert('users', user);
            \\    }
            \\}
            \\
            \\export function createUserRepository(config: Config): UserRepository {
            \\    const db = new Database(config.dbUrl);
            \\    return new DefaultUserRepository(db);
            \\}
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .structure = true },
                    .expected =
                    \\interface UserRepository {
                    \\    findById(id: string): Promise<User | null>;
                    \\    save(user: User): Promise<User>;
                    \\}
                    \\class DefaultUserRepository implements UserRepository {
                    \\    constructor(private db: Database) {}
                    \\    
                    \\    async findById(id: string): Promise<User | null> {
                    \\        const result = await this.db.query('SELECT * FROM users WHERE id = ?', [id]);
                    \\        return result ? this.mapToUser(result) : null;
                    \\    }
                    \\    
                    \\    async save(user: User): Promise<User> {
                    \\        return this.db.insert('users', user);
                    \\    }
                    \\}
                    \\function createUserRepository(config: Config): UserRepository {
                    \\    const db = new Database(config.dbUrl);
                    \\    return new DefaultUserRepository(db);
                    \\}
                    ,
                },
                .{
                    .flags = .{ .imports = true },
                    .expected =
                    \\import { Database } from './database';
                    \\import type { Config } from './config';
                    ,
                },
            },
        },
        .{
            .name = "test_cases",
            .source =
            \\import { describe, it, expect, beforeEach } from 'vitest';
            \\import { UserService } from '../src/UserService';
            \\
            \\describe('UserService', () => {
            \\    let userService: UserService;
            \\    
            \\    beforeEach(() => {
            \\        userService = new UserService();
            \\    });
            \\    
            \\    it('should create a user', async () => {
            \\        const userData = { name: 'John', email: 'john@example.com' };
            \\        const user = await userService.createUser(userData);
            \\        expect(user.id).toBeDefined();
            \\    });
            \\    
            \\    test('should validate user data', () => {
            \\        const invalidData = { name: '' };
            \\        expect(() => userService.validateUser(invalidData)).toThrow();
            \\    });
            \\});
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .tests = true },
                    .expected =
                    \\describe('UserService', () => {
                    \\    let userService: UserService;
                    \\    
                    \\    beforeEach(() => {
                    \\        userService = new UserService();
                    \\    });
                    \\    
                    \\    it('should create a user', async () => {
                    \\        const userData = { name: 'John', email: 'john@example.com' };
                    \\        const user = await userService.createUser(userData);
                    \\        expect(user.id).toBeDefined();
                    \\    });
                    \\    
                    \\    test('should validate user data', () => {
                    \\        const invalidData = { name: '' };
                    \\        expect(() => userService.validateUser(invalidData)).toThrow();
                    \\    });
                    \\})
                    ,
                },
                .{
                    .flags = .{ .imports = true },
                    .expected =
                    \\import { describe, it, expect, beforeEach } from 'vitest';
                    \\import { UserService } from '../src/UserService';
                    ,
                },
            },
        },
        .{
            .name = "combined_flags",
            .source =
            \\/**
            \\ * Service for managing user operations
            \\ */
            \\export interface UserService {
            \\    createUser(data: UserData): Promise<User>;
            \\    updateUser(id: string, data: Partial<UserData>): Promise<User>;
            \\}
            \\
            \\export class DatabaseUserService implements UserService {
            \\    constructor(private repo: UserRepository) {}
            \\    
            \\    async createUser(data: UserData): Promise<User> {
            \\        try {
            \\            return await this.repo.save(data);
            \\        } catch (error) {
            \\            throw new Error('Failed to create user');
            \\        }
            \\    }
            \\    
            \\    async updateUser(id: string, data: Partial<UserData>): Promise<User> {
            \\        return this.repo.update(id, data);
            \\    }
            \\}
            ,
            .extraction_tests = .{
                .{
                    .flags = .{ .signatures = true, .types = true },
                    .expected =
                    \\class DatabaseUserService implements UserService {
                    \\    constructor(private repo: UserRepository) {}
                    \\    
                    \\    async createUser(data: UserData): Promise<User> {
                    \\        try {
                    \\            return await this.repo.save(data);
                    \\        } catch (error) {
                    \\            throw new Error('Failed to create user');
                    \\        }
                    \\    }
                    \\    
                    \\    async updateUser(id: string, data: Partial<UserData>): Promise<User> {
                    \\        return this.repo.update(id, data);
                    \\    }
                    \\}
                    ,
                },
                .{
                    .flags = .{ .docs = true, .errors = true },
                    .expected =
                    \\/**
                    \\ * Service for managing user operations
                    \\ */
                    \\try {
                    \\            return await this.repo.save(data);
                    \\        } catch (error) {
                    \\            throw new Error('Failed to create user');
                    \\        }
                    ,
                },
            },
        },
    },
    .formatter_tests = .{
        .{
            .name = "function_formatting",
            .source =
            \\function longFunctionName(param1:string,param2:number,param3?:boolean):Promise<User|null>{return Promise.resolve(null);}
            ,
            .expected =
            \\function longFunctionName(
            \\    param1: string,
            \\    param2: number,
            \\    param3?: boolean
            \\): Promise<User | null> {
            \\    return Promise.resolve(null);
            \\}
            ,
            .options = .{
                .line_width = 50,
                .indent_size = 4,
            },
        },
        .{
            .name = "interface_formatting",
            .source =
            \\interface User{id:number;name:string;email?:string;profile:{bio:string;avatar?:string;};}
            ,
            .expected =
            \\interface User {
            \\    id: number;
            \\    name: string;
            \\    email?: string;
            \\    profile: {
            \\        bio: string;
            \\        avatar?: string;
            \\    };
            \\}
            ,
            .options = .{
                .indent_size = 4,
                .trailing_comma = false,
            },
        },
        .{
            .name = "arrow_function_formatting",
            .source =
            \\const processUsers=(users:User[])=>users.filter(user=>user.email).map(user=>({...user,processed:true}));
            ,
            .expected =
            \\const processUsers = (users: User[]) =>
            \\    users
            \\        .filter(user => user.email)
            \\        .map(user => ({
            \\            ...user,
            \\            processed: true
            \\        }));
            ,
            .options = .{
                .line_width = 60,
                .indent_size = 4,
            },
        },
        .{
            .name = "generic_type_formatting",
            .source =
            \\class Repository<T extends BaseEntity>{private items:Map<string,T>=new Map();async find<K extends keyof T>(key:K,value:T[K]):Promise<T[]>{return[];}}
            ,
            .expected =
            \\class Repository<T extends BaseEntity> {
            \\    private items: Map<string, T> = new Map();
            \\    
            \\    async find<K extends keyof T>(
            \\        key: K,
            \\        value: T[K]
            \\    ): Promise<T[]> {
            \\        return [];
            \\    }
            \\}
            ,
            .options = .{
                .indent_size = 4,
                .line_width = 50,
            },
        },
        .{
            .name = "import_export_formatting",
            .source =
            \\import{Component,useState,useEffect}from'react';import type{User,Props}from'./types';export{UserProfile,UserCard}from'./components';export default UserProfile;
            ,
            .expected =
            \\import {
            \\    Component,
            \\    useState,
            \\    useEffect
            \\} from 'react';
            \\import type {
            \\    User,
            \\    Props
            \\} from './types';
            \\export {
            \\    UserProfile,
            \\    UserCard
            \\} from './components';
            \\export default UserProfile;
            ,
            .options = .{
                .line_width = 40,
                .indent_size = 4,
            },
        },
        .{
            .name = "trailing_comma_option",
            .source =
            \\interface Config {
            \\    host: string;
            \\    port: number;
            \\    ssl: boolean;
            \\}
            ,
            .expected =
            \\interface Config {
            \\    host: string,
            \\    port: number,
            \\    ssl: boolean,
            \\}
            ,
            .options = .{
                .trailing_comma = true,
            },
        },
    },
}
